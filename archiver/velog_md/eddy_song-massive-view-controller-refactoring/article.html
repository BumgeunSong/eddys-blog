<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Massive View Controller를 해체해보자</title>
</head>
<body>
  <h1>Massive View Controller를 해체해보자</h1>
  <p><em>by eddy_song</em></p>
  <p>iOS 개발을 배우면서 짧은 시간 내에 다양한 프로젝트를 진행해봤다. </p>
<p>처음 보는 기능을 접하면, 당장 구현하기에 급급해진다. 어떻게든 돌아가게 만들고, 코드를 푸시하는데 집중한다. 일단 이것부터 하고 고치자. 이것부터 하고... 시야가 좁아진다.</p>
<p>하지만 그 과정을 거치면서 느꼈다. 실력이 늘기 위해서는, 더 나은 방법은 없을지 고민해야 한다. 적당히 되는 수준에서, 한 뎁스, 두 뎁스를 내려간다. 겉으로 별로 바뀌는 건 없다. 하지만 배우는 게 많다. </p>
<p>뎁스를 챙기려면, 집중할 부분을 선택해야 한다. 모든 걸 다 파볼 수는 없다. 방향을 잃지 않으려면 처음부터 내가 실력을 쌓고 싶은 부분을 의식적으로 설정해야 한다. </p>
<p>마치 무술가가, 똑같은 발차기를 계속 반복 연습하듯이 말이다. </p>
<p><img alt="kick" src="https://i.pinimg.com/originals/d5/9d/08/d59d08aaef8301e34b0b32f122c21e94.jpg"/></p>
<blockquote>
<p>당신이 요즘 연습하고 있는 발차기는 무엇인가?</p>
</blockquote>
<p>이번 프로젝트에서 나의 '발차기'는 <strong>'단위 테스트와 리팩토링'</strong>이었다. </p>
<p>객체 지향적인 코드, 역할이 잘 나눠진 코드를 만들기 위해서 코드를 여러번 뒤집었다.</p>
<p>기능은 단순했지만, 총 3번이나 갈아엎는 대공사를 했다. 전채 개발 시간의 50% 이상을 리팩토링에 사용한 것 같다. 그만큼 삽질도 많이 했다. </p>
<p>글이 꽤 길다. 하지만 iOS 개발을 하다보면 흔히 발생하는 상황들이다. 이 글을 다 읽고나면, 여러분도 <strong>코드 구조를 개선하는 힌트를 분명 얻을 수 있을 것</strong>이다. </p>
<h1 id="기능-소개">기능 소개</h1>
<p>리팩토링할 코드가 하는 일을 간단하게 이해하고 넘어가자.</p>
<p>에어비앤비 숙박 검색. 위치, 날짜, 가격 조건을 설정한다. 거기에 맞는 숙박 리스트를 받아온다.</p>
<p>이 중 오늘 얘기할 부분은 '위치 검색' 기능이다.</p>
<ol>
<li>검색 탭이 활성화되면, 사용자 현재 위치 근처의 장소들이 추천된다.</li>
<li>검색어를 입력하면 애플 맵을 사용해 검색어 자동완성이 뜬다.</li>
<li>검색어를 선택하면 2가지 선택지가 있다. 해당 검색어에 해당하는 결과가 하나뿐인 경우는 해당 결과로 위치 검색을 종료한다. 결과가 여러 개인 경우 다시 한번 상세 검색을 띄운다.</li>
</ol>
<p><img alt="location-search" src="https://user-images.githubusercontent.com/17468015/173227973-4daf7840-bc63-47f8-abfd-f4dd029a82c8.gif"/></p>
<h1 id="리팩토링-개요">리팩토링 개요</h1>
<p>했던 리팩토링 작업을 요약하면 3가지 파트로 나눌 수 있다.</p>
<ol>
<li>ViewController에서 데이터 소스와 데이터 로딩 분리하기.</li>
<li><code>UICollectionViewDelegate</code>를 DataSource에 합치기.</li>
<li>객체 간 의존성 추상화하고 DI Container로 주입하기.</li>
</ol>
<blockquote>
<p>물론 실제로는 이렇게 깔끔하고 논리적으로 진행되지 않았다. 좌충우돌의 연속이었을 뿐... 하지만 설명을 위해서 다듬어봤다.</p>
</blockquote>
<h1 id="리팩토링-1-viewcontroller에서-데이터-소스와-데이터-로딩-분리하기">리팩토링 1. ViewController에서 데이터 소스와 데이터 로딩 분리하기</h1>
<p>iOS MVC는 Massive View Controller라는 아주 오래된 농담이 있다. </p>
<p>하지만 뷰 컨트롤러가 거대해지는 이유는 MVC의 문제가 아니다. 역할 분리에 신경을 쓰지 않았기 때문이다. </p>
<p>MVP든, MVVM이든 다른 패턴이라도 역할 분리를 잘 하지 못하면 거대한 객체는 또 등장한다. </p>
<p>맨 처음 구현한 위치 검색 기능은, 그야말로 전형적인 거대 뷰 컨트롤러였다. </p>
<p><code>LocationSearchViewController</code>라는 하나의 객체가 다음의 역할을 모두 하고 있었다.</p>
<ul>
<li>SearchBar, CollectionView에 대한 설정과 레이아웃 세팅</li>
<li>CollectionView의 Delegate와 DataSource 역할</li>
<li>MapKit API와 서버 API에서 데이터 불러오기.</li>
</ul>
<blockquote>
<p><strong>자, 이제 거대 뷰 컨트롤러를 해체해보자!</strong></p>
</blockquote>
<p><img alt="tuna" src="https://cdn.isusanin.com/news/photo/201701/28481_7258_2417.jpg"/><br/>
(출처: 수산인신문)</p>
<h2 id="1-datasource-delegate-분리-️">1. DataSource, Delegate 분리 ✂️</h2>
<p>위치 검색 기능을 담당하는 <code>LocationSearchViewController</code> (이하 VC) 는 <code>UICollectionView</code> (이하 컬렉션 뷰)를 가지고 있다. </p>
<p>컬렉션 뷰는 데이터를 띄우거나 인터랙션이 있을 때 <code>UICollectionViewDataSource</code> (이하 DataSource)와 <code>UICollectionViewDelegate</code>(이하 Delegate)에 무엇을 해야할지 물어본다. </p>
<p>현재는 VC가 DataSource와 Delegate 메서드까지 직접 구현하고 있다.</p>
<p><img src="https://velog.velcdn.com/images/eddy_song/post/e54d20a7-36a7-4841-8d02-4a8bbab16a7b/image.png"/></p>
<p>이 두가지 역할을 별도 객체로 분리해보자. </p>
<p><strong>DataSource를 역할별로 분리하기!</strong></p>
<p>DataSource를 분리하는 것은 단순한데, 그 안에도 복잡한 부분이 있었다.</p>
<p>위치 검색은 처음에는 추천 장소를 보여주다가, 검색이 시작되면 검색 키워드를 보여준다. 그리고 상세 검색 때는 상세 검색 데이터를 보여준다.</p>
<p>기존의 DataSource 메서드는 이 변화를 조건문으로 처리하고 있었다.</p>
<pre><code class="language-swift"><span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> numberOfItemsInSection section<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> isSearching<span class="token punctuation">{</span>
        <span class="token keyword">return</span> searchResultData<span class="token punctuation">.</span><span class="token builtin">count</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> recommendationData<span class="token punctuation">.</span><span class="token builtin">count</span>
<span class="token punctuation">}</span></code></pre>
<p><code>isSearching</code> 이라는 변수를 사용해서 셀의 갯수를 지정했다.</p>
<p><code>isSearching</code>은 검색 바 입력 처리에서 바꿔주는 <code>Bool</code> 값이다. 처음에는 이런 식의 코드였다. </p>
<pre><code class="language-swift"><span class="token keyword">func</span> <span class="token function">searchBar</span><span class="token punctuation">(</span><span class="token number">_</span> searchBar<span class="token punctuation">:</span> <span class="token builtin">UISearchBar</span><span class="token punctuation">,</span> textDidChange searchText<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> searchText <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>
		    isSearching <span class="token operator">=</span> <span class="token boolean">false</span>
		    searchResultData<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		    collectionView<span class="token punctuation">.</span><span class="token function">reloadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
		    isSearching <span class="token operator">=</span> <span class="token boolean">true</span>
		    searchCompleter<span class="token punctuation">.</span>queryFragment <span class="token operator">=</span> searchText
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>조건문을 사용하면 기능이 추가될 때 코드를 수정해야한다. 좋지 않은 방법이다. </p>
<p>또 각 단계별로 Datasource를 분리해서 역할을 더 뚜렷하게 만들 필요가 있었다.</p>
<p>추천, 자동완성, 상세검색을 모두 별도의 DataSource로 분리했다. </p>
<p>아래는 추천 데이터를 담당하는 <code>RecommendationDataSource</code> 객체다.</p>
<pre><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">RecommendationDataSource</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDataSource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">var</span> recommendationData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Place</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> didLoadData<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>didLoadData<span class="token punctuation">:</span> @escaping <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>didLoadData <span class="token operator">=</span> didLoadData
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">let</span> location <span class="token operator">=</span> <span class="token builtin">Location</span><span class="token punctuation">.</span><span class="token function">makeRandomInKR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> recommendator <span class="token operator">=</span> <span class="token function">DefaultRecommendator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        recommendator<span class="token punctuation">.</span><span class="token function">recommend</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span> place <span class="token keyword">in</span>
            <span class="token keyword">guard</span> <span class="token keyword">let</span> place <span class="token operator">=</span> place <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>recommendationData <span class="token operator">=</span> place
            <span class="token function">didLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> numberOfItemsInSection section<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
        recommendationData<span class="token punctuation">.</span><span class="token builtin">count</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> cellForItemAt indexPath<span class="token punctuation">:</span> <span class="token builtin">IndexPath</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">UICollectionViewCell</span> <span class="token punctuation">{</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> cell <span class="token operator">=</span> collectionView<span class="token punctuation">.</span><span class="token function">dequeueReusableCell</span><span class="token punctuation">(</span>withReuseIdentifier<span class="token punctuation">:</span> <span class="token builtin">PlaceCell</span><span class="token punctuation">.</span>reuseIdentifier<span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">:</span> indexPath<span class="token punctuation">)</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">PlaceCell</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">UICollectionViewCell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token keyword">let</span> data <span class="token operator">=</span> recommendationData<span class="token punctuation">[</span>indexPath<span class="token punctuation">.</span>item<span class="token punctuation">]</span>
        cell<span class="token punctuation">.</span><span class="token function">setPlaceCell</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cell
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>이런 식으로 DataSource를 총 3개로 분리했다. </p>
<p>응집도가 훨씬 높은 객체를 만들 수 있었다. 추천, 자동완성, 최종 검색 각 단계에 따라서 서로 완전히 다른 인스턴스 변수를 참조하기 때문이다.</p>
<p><img alt="diagram_1" src="https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/separate_datasource.png"/></p>
<p>이제 상위 VC는 이벤트(검색 시작, 장소 선택)에 따라 서로 다른 Datasource를 갈아끼운다. 하나의 콜렉션뷰를 재활용하면서도, 데이터를 채우는 역할은 분리했다.</p>
<p>마찬가지로 Delegate도 분리했다. Delegate는 Cell에 대한 터치가 들어왔을 때 이벤트를 처리한다.  </p>
<p>그런데 Delegate 분리는 문제가 발생했다. 깔끔한 DataSource 분리와 달랐다. 여기에 대해 다음 챕터에 다시 설명하도록 하자.</p>
<h2 id="2-데이터-로딩-모델-분리-🥯">2. 데이터 로딩 모델 분리 🥯</h2>
<p>각 DataSource는 외부에서 데이터를 불러온다. 추천 데이터는 <strong>서버 API</strong>, 자동완성과 검색 결과는 <strong>MapKit API</strong>를 사용한다.</p>
<p>현재 코드는 DataSource가 직접 MapKit과의 소통과 네트워크 요청을 처리하고 있었다.</p>
<p>어떻게 하고 있었을까? 아래 코드를 보자.</p>
<pre><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">UIKit</span>
<span class="token keyword">import</span> <span class="token builtin">MapKit</span>

<span class="token keyword">class</span> <span class="token class-name">SearchCompletionDataSource</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDataSource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">var</span> searchResultData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">MKLocalSearchCompletion</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> searchCompleter <span class="token operator">=</span> <span class="token function">MKLocalSearchCompleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> didLoadData<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>didLoadData<span class="token punctuation">:</span> @escaping <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>didLoadData <span class="token operator">=</span> didLoadData
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        searchCompleter<span class="token punctuation">.</span>delegate <span class="token operator">=</span> <span class="token keyword">self</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// (...) Datasource 관련 메서드 생략</span>

	<span class="token comment">// 검색어를 MKLocalSearchCompleter에게 알려준다.</span>
    <span class="token keyword">func</span> <span class="token function">setQueryFragment</span><span class="token punctuation">(</span><span class="token number">_</span> queryFragement<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        searchCompleter<span class="token punctuation">.</span>queryFragment <span class="token operator">=</span> queryFragement
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">extension</span> <span class="token builtin">SearchCompletionDataSource</span><span class="token punctuation">:</span> <span class="token builtin">MKLocalSearchCompleterDelegate</span> <span class="token punctuation">{</span>
	<span class="token comment">// MKLocalSearchCompleter는 자동완성 결과를 delegate로 전달한다.</span>
	<span class="token comment">// Datasource는 결과를 인스턴스 변수에 저장하고, 상위 객체에 로딩 완료를 알린다.</span>
    <span class="token keyword">func</span> <span class="token function">completerDidUpdateResults</span><span class="token punctuation">(</span><span class="token number">_</span> completer<span class="token punctuation">:</span> <span class="token builtin">MKLocalSearchCompleter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        searchResultData <span class="token operator">=</span> searchCompleter<span class="token punctuation">.</span>results
        <span class="token function">didLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>DataSource 역할이면서, 외부 API에 데이터를 요청하는 역할을 같이 하고 있다. </p>
<p>객체 역할을 더 작게 쪼개고 싶어서 데이터 로딩 부분을 분리해냈다.</p>
<p>이쯤 되면 약간 고민이 되기 시작한다. 정말 이 역할을 꼭 분리해야하는가?</p>
<p>사실 누구나 '단일 책임 원칙'을 안다. 한 객체가 한 역할만 하게 해야한다. </p>
<p>그런데 어디까지가 하나의 역할인가? 그건 보는 사람마다 다르다. Data를 요청해 받아오는 로딩(Loading)과, View에 전달해주는 소싱(Sourcing)은 별도 역할이라고 봐야할까?</p>
<p>어쩌면 지나친 분리일 수도 있겠다 싶었다.</p>
<p>또 하나 고민해본 옵션이있다. DataSource를 컨트롤러 객체가 담당하지 않고, 모델 계층이 담당하도록 하면 어떨까?</p>
<p>ViewController에서 분리해놓고 보니 Datasource는 모델과 거의 비슷한 역할을 한다는 생각이 들었기 때문이다.</p>
<blockquote>
<p>DataSource는 사실 모델에 가깝지 않은가?</p>
</blockquote>
<p>하지만 리서치 결과 그게 아니라는 사실을 알았다. DataSource는 TableView, CollectionView에 데이터를 채우는 역할이다. 자연스럽게 <code>UIKit</code>에 의존한다. <code>UITableViewCell</code> 같은 타입 정보를 알아야 한다. 다시 말해, <code>import UIKit</code>이 들어갈 수밖에 없다.</p>
<p>MVC 패턴에서는 뷰와 모델의 관심사를 분리해야한다는 원칙이 있다. 모델은 UIKit에 완전히 독립적이어야 한다.</p>
<p>현재는 기능이 단순하기 때문에 데이터 소싱과, 데이터 로딩을 같이 하는 게 이상해보이지 않는다. 하지만 장기적으로 일관성 있는 계층 구조를 유지하기 위해서는 둘의 분리가 필요하다는 결론이 나왔다.</p>
<p>Data를 요청해 받아오는 로딩(Loading)과, View에 전달해주는 소싱(Sourcing)을 별도 역할로 분리했다. </p>
<p>'컨트롤러' 계층에 속하는 DataSource 객체와 '모델' 계층에 속하는 Data Loading 객체로 분리했다. </p>
<p>이제 DataSource는 데이터를 저장하지 않는다. 모델에게 요청해서, 뷰로 전달해줄 뿐이다.</p>
<p><img alt="diagram_2" src="https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/separate_dataloading.png"/></p>
<h2 id="3-value-type을-캡처하는-클로저-">3. Value type을 캡처하는 클로저 ❎</h2>
<p>이 때 한 가지 문제가 발생한다.</p>
<p>데이터 로딩 모델은 <code>struct</code>로 만들었다. <code>struct</code>는 value type이 된다. value type은 불변성 덕분에 부수효과가 발생하지 않고, Stack에서 다루기 때문에 효율적이다. </p>
<p>별다른 이유가 없으면 기본적으로 value type으로 타입을 정의해준다.</p>
<p>여기에 데이터를 비동기로 요청하는 메서드를 추가했다. 완료되면 자신의 인스턴스 변수에 저장한다.</p>
<p><img alt="error_1" src="https://raw.githubusercontent.com/adnpark/daily-devlog/f0abac63dec4c01144b872613ab174ca84e64a2b/eddy/mutating_self_error.png"/></p>
<p>탈출 클로저는 self 파라미터를 캡처할 수 없다는 에러가 뜬다. </p>
<p>우리는 <code>getRecommendation()</code> 이라는 함수에 인자로 클로저를 넘긴다. </p>
<p>탈출 클로저는 해당 스코프가 끝난 뒤에 나중 어떤 시점에 실행된다. 그때 이 클로저는 받아온 데이터를 저장하기 위해 DefaultRecommendator 모델을 기억(캡처)한다.</p>
<blockquote>
<p>탈출 클로저가 Value type을 캡처하고 있다.</p>
</blockquote>
<p>Value type은 할당 시 참조가 아닌 값 전체를 복사한다. 클로저가 value type을 캡처하면 복사가 일어난다.</p>
<p>클로저 안에 캡처되는 <code>DefaultRecommendator</code> 인스턴스는 실제 클로저를 파라미터로 넘기는 <code>DefaultRecommendator</code>  인스턴스와 '다른' 인스턴스다.</p>
<p>따라서 나중에 이 <code>DefaultRecommendator</code>를 찾아와서 값을 저장해준다는 게 말이 되지 않는다. </p>
<p>에러는 이 말을 하고 있었다.</p>
<p>특정 스코프가 완료(return)된 후에 목표한 데이터에 접근하려면 어떻게 해야할까? </p>
<p><strong>참조 타입(Reference type)으로 만들어줘야 한다.</strong> 참조 타입은 힙에 저장되고 참조가 복사된다. '고유성'을 갖는다. 다른 스코프에서도 식별가능하다.</p>
<p>데이터를 참조 타입으로 만드는 방법은 2가지가 있다.</p>
<ol>
<li>데이터를 요청하는 <code>DefaultRecommendator</code> 타입을 <code>class</code>로 바꾸는 것</li>
<li><code>DefaultRecommendator</code>의 프로퍼티이자 데이터를 저장하는 <code>recommendationData</code>를 <code>class</code>로 감싸는 것</li>
</ol>
<p>첫번째 방법이 가장 단순해보인다. 가장 먼저 떠오르는 해결책이다. </p>
<blockquote>
<p>struct로 하니까 안 된다고? 그럼 class로 바꿔.</p>
</blockquote>
<p>하지만 여기서 우리가 클로저에서 캡처하고자 하는 목표는 <code>DefaultRecommendator</code>가 아니라 변수인 <code>recommendationData</code>다.</p>
<p>물론 1번으로 문제는 해결할 수 있다.<br/>
<code>DefaultRecommendator</code>가 <code>recommendationData</code>를 갖고 있다. <code>DefaultRecommendator</code>를 <code>class</code>로 바꿔 Heap에 저장되게 한다. <code>recommendationData</code>도 자연스럽게 힙에 저장된다. </p>
<p>하지만 참조 타입의 단점인 부수효과(Side effect)의 범위가 '필요 이상으로' 넓어진다. </p>
<p>만약 <code>DefaultRecommendator</code>에 또다른 인스턴스 변수가 존재한다면, 그 데이터도 레퍼런스 타입이 된다. 우리는 가급적 Value type을 많이 쓰고 싶다!</p>
<p>예측가능성, 스레드안전성, 테스트 용이성 등 Value type이 가지는 장점을 유지하기 위해서다. </p>
<p>따라서 Reference type이 되는 범위, 부수 효과가 생기는 범위는 가급적 최소화하는 게 좋다. </p>
<p>2번째 방법을 선택하자.</p>
<p><code>recommendationData</code>는 배열이다. 배열(Array)은 값 타입이다. 참조 타입으로 바꾸기 위해 값을 감싸는 별도의 객체를 만들어줘야 한다.</p>
<p>이 객체 이름을 <code>Box</code>라고 하자.</p>
<pre><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> value<span class="token punctuation">:</span> T
<span class="token punctuation">}</span></code></pre>
<p><code>Box</code>는 참조 타입이다. 클로저는 참조를 캡처한다. 나중에 요청한 함수 스코프가 종료된 후에도 데이터 응답을 넣어줄 수 있다.</p>
<p>동시에 <code>DefaultRecommendator</code> 타입은 <code>struct</code>로 그대로 유지할 수 있다.</p>
<h1 id="리팩토링-2-delegate-분리-문제-해결하기">리팩토링 2. Delegate 분리 문제 해결하기</h1>
<p>여기까지 하고, 얼마 후 다시 코드를 봤다. </p>
<p>그런데 실행 흐름이 이해가 되지 않았다. 일관되지 않은 실행 흐름과 참조가 이곳저곳에 등장했다.</p>
<blockquote>
<p>분명 분리를 시켰는데 왜 더 복잡해진 거지?</p>
</blockquote>
<p>원인은 'Delegate의 분리'였다.</p>
<p>챕터 1에서 우리는 DataSource와 Delegate를 모두 VC에서 분리시켰다.</p>
<p>UIKit에서 DataSource는 주로 컬렉션 뷰의 출력 흐름을 담당하고, Delegate는 입력 흐름을 담당한다. </p>
<p>좀 더 구체적으로 말하면, 지금 Delegate는 컬렉션 뷰의 셀 하나가 '선택'됐을 때 처리 로직을 담당하고 있다.</p>
<p>문제는 이 셀 선택의 처리 로직은 다른 객체에 많이 의존한다는 점이다.</p>
<p>상황에 따라 셀이 선택되면 이런 일을 해야 한다.</p>
<ul>
<li>DataSource가 가진 배열에 <code>IndexPath</code>로 접근해서, 선택된 셀에 해당하는 데이터 가져오기.</li>
<li><code>MapKit</code>으로 LocalSearch를 실행하고, 결과를 받아 상세 검색 담당 DataSource에게 넘겨주기.</li>
<li><code>NavigationBar</code>에 들어있는 <code>SearchBar</code>의 텍스트 초기화/변경하기.</li>
<li><code>NavigationBar</code>에 새로운 뷰 컨트롤러 추가하기 (화면 전환)</li>
</ul>
<p>가만히 살펴보자. 자기 혼자 하는 일을 하나도 없다. 전부 다른 객체를 참조한다.</p>
<p>그런데 이런 의존성이 높은 객체를 급하게 분리하다보니 이상한 상황이 벌어졌다. Delegate가 콜렉션 뷰와 네비게이션, 그리고 다음에 등장할 뷰 컨트롤러까지 알게 됐다.</p>
<p>아래 코드에서 생성자(init)를 유심히 보자. 콜렉션 뷰와 네비게이션 컨트롤러가 넘겨진다...?</p>
<pre><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">DetailSearchDelegate</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDelegate</span> <span class="token punctuation">{</span>

    <span class="token keyword">let</span> searchDateVC <span class="token operator">=</span> <span class="token function">SearchDateViewController</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> navigationController<span class="token punctuation">:</span> <span class="token builtin">UINavigationController</span><span class="token operator">?</span>
    <span class="token keyword">let</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token operator">?</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span>navigation<span class="token punctuation">:</span> <span class="token builtin">UINavigationController</span><span class="token punctuation">,</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>navigationController <span class="token operator">=</span> navigation
        <span class="token keyword">self</span><span class="token punctuation">.</span>collectionView <span class="token operator">=</span> collectionView
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> didSelectItemAt indexPath<span class="token punctuation">:</span> <span class="token builtin">IndexPath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">guard</span> <span class="token keyword">let</span> datasource <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>collectionView<span class="token operator">?</span><span class="token punctuation">.</span>dataSource <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">DetailSearchLocationDataSource</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>
        <span class="token keyword">let</span> mapItem <span class="token operator">=</span> datasource<span class="token punctuation">.</span>searchResultData<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> place <span class="token operator">=</span> <span class="token builtin">PlaceFactory</span><span class="token punctuation">.</span><span class="token function">makePlace</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> mapItem<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>
        searchDateVC<span class="token punctuation">.</span>queryParameter<span class="token operator">?</span><span class="token punctuation">.</span>place <span class="token operator">=</span> place
        <span class="token keyword">self</span><span class="token punctuation">.</span>navigationController<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">pushViewController</span><span class="token punctuation">(</span>searchDateVC<span class="token punctuation">,</span> animated<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span></code></pre>
<p>아래 <code>didSelectItemAt</code>에선 dataSource의 searchResultData까지 꺼내오고 있다. 닷(.)을 2개나 써서 말이다. (디미터 법칙 위반) </p>
<p>3개의 Delegate가 다 이런 식으로 다른 객체를 참조하고 있었다. 실행 흐름이 매우 복잡해질 수 밖에.</p>
<p>현재 상태를 다이어그램으로 요약하면 다음과 같다.</p>
<p><img alt="before_diagram" src="https://user-images.githubusercontent.com/17468015/173004810-5c99ae45-9158-4fd7-ad26-fd0e52f41fd8.png"/></p>
<blockquote>
<p>이제 리팩토링으로 다시 개선해보자!</p>
</blockquote>
<h2 id="1-delegate와-datasouce를-합쳐서-하위-controller로-만들기-">1. Delegate와 DataSouce를 합쳐서 하위 Controller로 만들기 🕹</h2>
<p>앞서 말했듯이, Delegate는 무언가를 하기 위해서 DataSource 혹은 ViewController에 의존한다.</p>
<p><code>didSelectItemAt</code>에서 넘겨받은 IndexPath를 가지고 DataSource에게 이 Index가 어떤 데이터인지 알아낸다. </p>
<p>그 다음으로 흔한 작업. 알아낸 데이터를 다음 VC로 넘겨주고, 다음 VC를 화면에 띄우는 것이다. 이때 다음 화면을 담당하는 VC와 화면을 띄우기 위한 NavigtaionController를 아는 것은 상위 뷰 컨트롤러다.</p>
<p>즉 Delegate의 실제 구현은 ViewController나 Datasource와 관련성이 매우 높다. </p>
<p>그러다보니 과도한 의존 관계가 생겨난 것이다. 이걸 끊기 위해선 위임이 필요하다. Delegate는 정보 전달만 하고, 작업은 ViewController나 DataSource에게 시켜야겠지.</p>
<p>하지만 그러면 문제가 있다. Delegate를 분리한 이유가 없어진다. 어차피 자기 혼자 처리하는 일도 없는데 왜 별도 객체를 만드느냔 말이야.</p>
<p>그럼 어떻게 해야할까?</p>
<p>뭘 어떻게 해. 합쳐야지.</p>
<p>Delegate를 떼어냈다가 오히려 실행 흐름이 복잡해졌다. 물론 지금 생각하면 Delegate 자체 때문이라기보다는 Delegate를 분리하면서 역할 위임을 제대로 안했기 때문이다. </p>
<p>하지만 객체를 작게 분리하는 게 항상 좋은 게 아니라는 점을 깨달았다.  쉽게 생각하면 무조건 분리가 좋은 것 같다.</p>
<p>오히려 같은 데이터를 빈번하게 참조하는 메서드는, 데이터를 공유할 수 있는 같은 객체에 둬야 한다. 그래야 객체의 응집도가 높아진다.</p>
<p>Delegate를 합칠 때는 2가지 선택지가 있었다.</p>
<ul>
<li>DataSource에 합치기</li>
<li>ViewController에 합치기.</li>
</ul>
<p>더 많이 관련이 있는 쪽에 합치는 게 정답이겠지. </p>
<p>현재 상황에서 Delegate 메서드는 양쪽 다 의존하는 정도가 비슷했다.</p>
<p>DataSource는 3개로 작게 나누어놓았기에 비교적 역할이 간단했다. ViewController는 이미 DataSource를 전환하고, 화면을 바꾸는 로직이 많이 들어있었다. </p>
<p>그래서 DataSource와 Delegate를 합치기로 했다.</p>
<p>적절한 이름이 뭘지 고민했다. (DataSource와 Delegate를 합쳤으니 DelegateDataSource??)</p>
<p>생각해보니 그냥 Controller라고 하면 될 것 같았다. View와 Model 사이를 중재하는 역할이 전부다. 전형적인 Controller 역할이다. 보통 Controller라고 하면 ViewController가 일반적이지만, ViewController만 Controller라는 법은 없다.</p>
<p>아래는 둘을 합쳐서 만든 <code>LocationSearchRecommendationController</code> 객체다.</p>
<pre><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">LocationSearchRecommendationController</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDataSource</span> <span class="token punctuation">{</span>

<span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> didSelectItemAt indexPath<span class="token punctuation">:</span> <span class="token builtin">IndexPath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> place <span class="token operator">=</span> recommendator<span class="token operator">?</span><span class="token punctuation">[</span>indexPath<span class="token punctuation">.</span>item<span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">Place</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>delegate<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">didSelectPlace</span><span class="token punctuation">(</span>place<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
	  <span class="token comment">// ... 생략</span>
<span class="token punctuation">}</span></code></pre>
<p>어지러운 외부 참조가 사라졌다. 셀 선택시 Index의 데이터를 파악하기가 쉽다.</p>
<h2 id="2-하위-컨트롤러에서-상위-컨트롤러에게-작업-위임하기-️">2. 하위 컨트롤러에서 상위 컨트롤러에게 작업 위임하기 ⚽️</h2>
<p>위의 함수 안을 살펴보자. self.delegate를 호출하고 있다. 이건 왜 추가됐을까?</p>
<p>아까 전에 Delegate는 DataSource를 참조하는 것 외에도, 화면 전환 로직도 실행한다고 했다.</p>
<p>하지만 화면 전환에 관련된 NavigationBar, SearchBar, ViewController는 이 <code>LocationSearchRecommendationController</code>의 역할이라고 하기 어렵다. </p>
<p>이 하위 컨트롤러의 역할은 단순하다. '추천 장소' 데이터를 관리한다. 추천 데이터를 모델에서 가져온다. 뷰에 뿌려준다. 뷰에서 셀이 선택되면, 그 장소가 어디인지 알려준다. </p>
<p>그러면 그 외의 모든 로직은?<br/>
위임한다.</p>
<p>하위 컨트롤러와 상위 뷰 컨트롤러를 Delegate pattern으로 연결한다. 추천 데이터 담당 컨트롤러는 delegate 프로토콜에 정의된 <code>delegate?.didSelectPlace(place)</code> 을 호출한다. 그리고 작업을 끝낸다. </p>
<p>상위 ViewController의 이름은 <code>LocationSearchViewController</code>다. 이 VC는 하위 컨트롤러의 Delegate 프로토콜인 <code>LocationSearchRecommendationControllerDelegate</code>를 채택한다. 그리고 데이터가 로딩/선택되었을 때 해야할 일을 정의한다.</p>
<pre><code class="language-swift"><span class="token keyword">protocol</span> <span class="token builtin">LocationSearchRecommendationControllerDelegate</span><span class="token punctuation">:</span> <span class="token builtin">AnyObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">didLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function">didSelectPlace</span><span class="token punctuation">(</span><span class="token number">_</span> place<span class="token punctuation">:</span> <span class="token builtin">Place</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<pre><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">LocationSearchViewController</span><span class="token punctuation">:</span> <span class="token builtin">LocationSearchRecommendationControllerDelegate</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">didLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>async <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>collectionView<span class="token punctuation">.</span><span class="token function">reloadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">func</span> <span class="token function">didSelectPlace</span><span class="token punctuation">(</span><span class="token number">_</span> place<span class="token punctuation">:</span> <span class="token builtin">Place</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span>async <span class="token punctuation">{</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">moveToNextVC</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> place<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="3-delegate냐-closure냐-">3. Delegate냐, Closure냐? 🆚</h2>
<p>위의 코드에서 ViewController에게 작업을 위임하는 방법으로 Delegate 패턴을 썼다. </p>
<blockquote>
<p>하지만 이게 최선일까? 🧐</p>
</blockquote>
<p>Delegate 대신 Closure를 쓰는 방법도 있다. </p>
<p>Delegate와 Closure는 객체간 1:1 커뮤니케이션을 가능하게 하고, 둘 다 발신하는 객체가 수신하는 객체를 몰라도 된다. </p>
<p>이 둘은 약한 결합을 만든다. 다시 말해 수신 객체가 바뀌어도 발신 객체의 코드는 변화하지 않는다.</p>
<p>즉, 둘 다 우리가 원하는 바를 달성할 수 있다.</p>
<p>이 둘의 장단점은 무엇일까? 이렇게 설명해보자.</p>
<blockquote>
<p>Delegate의 장점: 써야할 코드가 많다.<br/>
Delegate의 단점: 설명하는 코드가 많다.</p>
</blockquote>
<blockquote>
<p>Closure의 장점: 써야할 코드가 적다.<br/>
Closure의 단점: 설명하는 코드가 적다.</p>
</blockquote>
<p>Closure는 문법이 간단해서 쓰기 쉽다. 웬만하면 Closure로 다 해결이 가능하다. </p>
<p>하지만 Closure는 작업 단위로만 구성된다. 별도의 문법이나 설명이 없다. <strong>비슷한 Closure가 많아지면, 점점 복잡해지고 읽기가 어려워진다.</strong></p>
<p>Delegate는 Protocol 타입을 추가로 구현한다. 써야할 코드가 더 많고, 약간 번거롭다. </p>
<p>하지만 두 객체 간 커뮤니케이션이 protocol에 정의된다. 따라서 커뮤니케이션 흐름이 여러개 있을 때, 좀 더 정돈된 코드를 만들 수 있다. <strong>Protocol 타입을 추가로 작성하기가 번거롭지만, 바로 그 점 때문에 복잡한 상황에서 가독성이 더 좋다.</strong></p>
<p>그래서 내가 Delegate와 Closure를 결정하는 기준이 있다. </p>
<blockquote>
<p>커뮤니케이션이 하나인가, 2개 이상인가.</p>
</blockquote>
<p>하나라면 간단하게 Closure를, 2개 이상으로 많아지면 Delegate를 쓴다.</p>
<p>Apple이 구현한 API도 다소 비슷한 구석이 있다. 네트워크 요청을 수행하는 URLSession DataTask를 예로 들어보자. </p>
<p>URLSession은 네트워크 요청 결과를 처리할 때 dataTask와 커뮤니케이션을 한다. </p>
<p>간단한 <strong>클로저</strong>를 콜백으로 넘기는 방법과, <strong><code>URLSessionDataTaskDelegate</code></strong>를 구현하는 방법 2가지가 있다.</p>
<p>이 둘의 차이는 커뮤니케이션이 한 번이냐, 여러번이냐다. 콜백으로 넘기는 클로저는 최종 완료시에 한번 실행된다. 단순한 커뮤니케이션 흐름이다.</p>
<p>URLSessionDelegate는 여러 이벤트가 있다. willCacheResponse, willPerformHTTPRedirection, didCompleteWithError 등. 커뮤니케이션 흐름이 복잡하다. 그래서 Delegate를 쓰지 않았을까 생각한다. </p>
<h2 id="여기까지-결과">여기까지 결과</h2>
<p>위치 검색 기능으로 다시 돌아오자. </p>
<p>하위 컨트롤러는, 데이터가 로딩/선택 됐을 때 작업을 상위 컨트롤러에게 위임한다. </p>
<p>즉, 2개 이상의 커뮤니케이션 흐름을 가진다. </p>
<p>게다가 하나의 ViewController가 3개의 컨트롤러를 가진다. 자칫 흐름이 매우 복잡해질 수 있다. 따라서 비록 써야할 코드는 많지만, Delegate 패턴을 쓰는 게 더 깔끔했다. </p>
<p>코드를 리팩토링한 후 구조는 이렇게 변했다.</p>
<p><img alt="before" src="https://user-images.githubusercontent.com/17468015/173010397-bb277c9f-6a9a-4246-bf66-4598bf070e90.png"/></p>
<h1 id="리팩토링-3-객체-간-의존성-추상화하고-di-container로-주입하기">리팩토링 3. 객체 간 의존성 추상화하고 DI Container로 주입하기</h1>
<p>뷰 컨트롤러에서 많은 로직을 분리했을 때 좋은 점 중 하나는, 바로 단위 테스트가 쉬워진다는 것이다. <code>UIViewController</code>는 <code>UIKit</code>에 의존한다. <code>UIView</code>와 강하게 결합돼있다. 테스트를 하기가 까다롭다. </p>
<p>하지만 뷰 컨트롤러에서 로직을 많이 분리하면, <code>UIKit</code>에 의존하지 않는 로직이 많이 생긴다. 그 부분을 따로 테스트할 수 있다.</p>
<p>이제 각 객체가 잘 작동하는지 테스트를 해보자.</p>
<p>현재는 상위 컨트롤러가 하위 컨트롤러에게 의존한다. 하위 컨트롤러는 데이터 로딩 모델에게 의존한다. </p>
<p>먼저 하위 컨트롤러를 테스트한다고 가정하자. 그러면 데이터를 불러오는 데이터 로딩 모델에 대한 의존성을 분리해야한다. </p>
<p>왜냐고? 데이터 로딩 모델 의존성을 그대로 두고, 하위 컨트롤러의 메서드를 실행한다고 생각해보자. 직접 HTTP 요청을 하는 것까지 우리가 테스트하는 '단위'에 들어가버린다. 네트워크 요청이 포함된 테스트는 느리고, 외부의 영향을 받아 결과가 달라질 수 있다.</p>
<p>의존성을 분리하는 가장 쉬운 방법은? </p>
<p>의존성을 추상화하는 것이다. 다시 말해 테스트 대상이 구체 타입이 아닌 추상 타입을 사용하도록 한다. </p>
<p><strong>[Before]</strong> <code>DataSource</code> -&gt; <code>DataLoading</code></p>
<p><strong>[After]</strong> <code>DataSource</code> -&gt; <code>DataLoadingProtocol</code> &lt;- <code>DataLoading</code></p>
<p>의존성을 주입할 수 있는 인터페이스를 열어준다. (생성자, 메서드, 프로퍼티) </p>
<p>테스트 대상 객체를 사용하는 쪽에서 구체 타입을 집어넣어줄 수 있도록 만든다. 다시 말해, <strong>의존성을 주입</strong>할 수 있게 만든다.</p>
<p>추상 타입으로 만들고, 외부에서 갈아끼울 수 있도록 만들면, 이제 사용하는 시점 (테스트하는 시점)에 서로 다른 구체 객체를 넣어서 실행시킬 수 있다. </p>
<p>테스트 시점에 실제 네트워크 요청을 하지 않는 가짜 객체 (Test Double)을 넣어주면 된다.</p>
<p>'의존성 역전'은 객체 간 의존성을 런타임에 갈아끼울 수 있도록 만든다. 덕분에 객체 간 결합도를 낮아진다. 테스트를 하기 쉬워진다.</p>
<h2 id="1-프로토콜로-의존성-추상화하기-의존성-역전-">1. 프로토콜로 의존성 추상화하기 (의존성 역전) 🔄</h2>
<p>먼저 데이터를 불러오는 코드를 추상화한다. </p>
<p>추천 장소를 불러오는 모듈을 예로 들어보자. </p>
<p>추천 장소를 불러오는 모듈의 '책임'은 다음과 같다.</p>
<ul>
<li><strong>현재 위치</strong>를 넣으면 <strong>추천 장소를 불러와서 저장</strong>하고 비동기로 알려준다.<br/>
<code>func loadRecommendation(for location: Location, then completion: @escaping () -&gt; Void)</code> </li>
<li>콜렉션 뷰를 구성하기 위한 <strong>전체 데이터(Place)의 갯수</strong>를 알려준다.<br/>
<code>var count: Int</code></li>
<li><strong>N번째 장소(Place)의 데이터</strong>를 반환한다.<br/>
<code>subscript(index: Int) -&gt; Place?</code></li>
</ul>
<pre><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">DefaultRecommendator</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">let</span> httpService<span class="token punctuation">:</span> <span class="token builtin">HTTPRecommandService</span>
    <span class="token keyword">private</span> <span class="token keyword">var</span> recommendationData <span class="token operator">=</span> <span class="token function">Box</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Place</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">var</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
        recommendationData<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token builtin">count</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Place</span><span class="token operator">?</span> <span class="token punctuation">{</span>
        <span class="token keyword">guard</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>recommendationData<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">nil</span> <span class="token punctuation">}</span>
        <span class="token keyword">return</span> recommendationData<span class="token punctuation">.</span>value<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>httpService<span class="token punctuation">:</span> <span class="token builtin">HTTPRecommandService</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>httpService <span class="token operator">=</span> httpService
    <span class="token punctuation">}</span>
    
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">loadRecommendation</span><span class="token punctuation">(</span><span class="token keyword">for</span> location<span class="token punctuation">:</span> <span class="token builtin">Location</span><span class="token punctuation">,</span> then completion<span class="token punctuation">:</span> @escaping <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> recommendationData <span class="token operator">=</span> recommendationData
        httpService<span class="token punctuation">.</span><span class="token function">getRecommendation</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span> places <span class="token keyword">in</span>
            <span class="token keyword">if</span> <span class="token keyword">let</span> places <span class="token operator">=</span> places <span class="token punctuation">{</span>
                recommendationData<span class="token punctuation">.</span>value <span class="token operator">=</span> places
            <span class="token punctuation">}</span>
            <span class="token function">completion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>(HttpService는 API 요청을 실행하는 모듈을 추상화한 것이다. 이 부분도 의존성 역전을 시켜두었지만 분량상 생략한다.)</p>
<p>위의 코드를 이제 추상 타입으로 만들어보자.<code>PlaceRecommanding</code>으로 따로 분리한다.</p>
<pre><code class="language-swift"><span class="token keyword">protocol</span> <span class="token builtin">PlaceRecommanding</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Place</span><span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">loadRecommendation</span><span class="token punctuation">(</span><span class="token keyword">for</span> location<span class="token punctuation">:</span> <span class="token builtin">Location</span><span class="token punctuation">,</span> then completion<span class="token punctuation">:</span> @escaping <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Void</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> </code></pre>
<p><code>LocationSearchRecommendationController</code>로 가보자. 이 컨트롤러는 <code>PlaceRecommanding</code>를 사용하는 쪽이 된다. </p>
<p>인스턴스 변수로 <code>var dependency: PlaceRecommanding?</code> 를 선언한다. 추상 타입이다.  </p>
<p>생성자를 통해 해당 인스턴스 변수에 들어갈 구체 타입을 넣어준다. <strong>생성자를 눈여겨보자.</strong></p>
<pre><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">LocationSearchRecommendationController</span><span class="token punctuation">:</span> <span class="token builtin">NSObject</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDataSource</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDelegate</span><span class="token punctuation">,</span> <span class="token builtin">UICollectionViewDelegateFlowLayout</span>  <span class="token punctuation">{</span>
    
    <span class="token keyword">weak</span> <span class="token keyword">var</span> delegate<span class="token punctuation">:</span> <span class="token builtin">LocationSearchRecommendationControllerDelegate</span><span class="token operator">?</span>
    
    <span class="token keyword">private</span> <span class="token keyword">var</span> dependency<span class="token punctuation">:</span> <span class="token builtin">PlaceRecommanding</span><span class="token operator">?</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>dependency<span class="token punctuation">:</span> <span class="token builtin">PlaceRecommanding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>dependency <span class="token operator">=</span> dependency
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">func</span> <span class="token function">getRecommendation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> location <span class="token operator">=</span> <span class="token builtin">Location</span><span class="token punctuation">.</span><span class="token function">makeRandomInKR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        dependency<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loadRecommendation</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>
            <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span>delegate<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">didLoadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// MARK: - UICollectionViewDataSource</span>
    
    <span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> numberOfItemsInSection section<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
        dependency<span class="token operator">?</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">func</span> <span class="token function">collectionView</span><span class="token punctuation">(</span><span class="token number">_</span> collectionView<span class="token punctuation">:</span> <span class="token builtin">UICollectionView</span><span class="token punctuation">,</span> cellForItemAt indexPath<span class="token punctuation">:</span> <span class="token builtin">IndexPath</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">UICollectionViewCell</span> <span class="token punctuation">{</span>
        <span class="token keyword">guard</span> <span class="token keyword">let</span> cell <span class="token operator">=</span> collectionView<span class="token punctuation">.</span><span class="token function">dequeueReusableCell</span><span class="token punctuation">(</span>withReuseIdentifier<span class="token punctuation">:</span> <span class="token builtin">RecommendedPlaceCell</span><span class="token punctuation">.</span>reuseIdentifier<span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">:</span> indexPath<span class="token punctuation">)</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">RecommendedPlaceCell</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">UICollectionViewCell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        
        <span class="token keyword">guard</span> <span class="token keyword">let</span> data <span class="token operator">=</span> dependency<span class="token operator">?</span><span class="token punctuation">[</span>indexPath<span class="token punctuation">.</span>item<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">UICollectionViewCell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        
        cell<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cell
    <span class="token punctuation">}</span></code></pre>
<p>이제 컨트롤러와 데이터 로딩 모델은 둘다 프로토콜 (추상 타입)에 의존하게 되었다. </p>
<p>이런 식으로 3개 컨트롤러에 모두 적용해주었. 이 그림을 보면 이해가 쉽다.</p>
<p><img alt="inversion" src="https://github.com/BumgeunSong/blog-reaction-friends/blob/main/eddy/Inversion.png?raw=true"/></p>
<p><strong>초록색은 추상 타입,</strong> <strong>주황색은 구체 타입</strong>이다.</p>
<p>각각의 컨트롤러는 프로토콜에 의존해 데이터를 불러온다. 각 모델은 프로토콜을 채택한다.</p>
<h2 id="2-di-container로-의존성-주입하기-">2. DI Container로 의존성 주입하기 💉</h2>
<p>의존성을 추상화했으니, 실제로 런타임에 구체 객체를 넣어줘야 한다.<br/>
<code>LocationSearchRecommendationController</code>가 <code>PlaceRecommanding</code> 타입을 필요로 한다. 그러니<code>PlaceRecommanding</code>을 채택한 구체 객체가 어떤 시점에든 들어가줘야 제대로 작동이 된다.</p>
<p>이걸 의존성 주입이라고 한다.</p>
<blockquote>
<p>근데 의존성을 넣어주는 책임은 어떤 객체가 담당해야할까?</p>
</blockquote>
<p>쉽게 떠오르는 건, 상위의 <code>LocationSearchVC</code>다. 아래 빨간색으로 표시된 객체다.</p>
<p><img alt="inversion_highlight" src="https://github.com/BumgeunSong/blog-reaction-friends/blob/main/eddy/inversion_highlight.png?raw=true"/></p>
<p><code>LocationSearchVC</code>가 <code>RecommendationController</code>를 생성할 때, <code>Recommendator</code>라는 구체 객체를 인자로 넣어준다. </p>
<p><code>Recommendator</code>도 <code>HTTPRecommandService</code>에 의존한다. <code>Recommendator</code>를 생성할 때는 <code>ResponseSuccessStub</code>이라는 테스트용 객체를 넣어준다.</p>
<p>이런 코드가 나온다.</p>
<pre><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">var</span> recommendationController <span class="token operator">=</span> <span class="token function">LocationSearchRecommendationController</span><span class="token punctuation">(</span>
	dependency<span class="token punctuation">:</span> <span class="token function">Recommendator</span><span class="token punctuation">(</span>
    	httpService<span class="token punctuation">:</span> <span class="token function">ResponseSuccessStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre>
<p><code>LocationSearchVC</code>가 결국 구체 타입을 지정해주고 있다. 다른 말로 하면 <code>LocationSearchVC</code>는 구체 타입들과 강하게 결합해있다. </p>
<p>강하게 결합되어있다는 게 무슨 뜻이냐고? </p>
<p>구체 타입을 갈아끼워줄 상황을 생각해보자. 우리가 LocationVC의 코드를 고쳐야 하는가? 그러면 LocationVC가 구체 타입들과 결합된 것이다.</p>
<p>LocationVC가 모르게, 그 상위에 있는 VC에서 해야할까? </p>
<p>그래도 LocationVC의 상위 객체는 구체 객체를 직접 알아야 한다. 마치 수건 돌리기처럼, 의존성을 위로 패스하는 방법밖에 되지 않는다.</p>
<p>그러니까 상황을 요약하자면 다음과 같다.</p>
<blockquote>
<p>어디선가는 구체 타입을 주입해줘야 한다.<br/>
근데 구체 타입을 주입해주는 객체는 구체 타입에 결합이 된다?</p>
</blockquote>
<p>여기서 주입을 다시한번 설명하고 넘어가자. </p>
<p>상위 객체가 필요한 의존성을 추상 타입으로 정의한다. 그 안에 하위 구체 타입을 넣어준다. 생성자 혹은 프로터피를 사용해서.</p>
<p>앱의 이곳 저곳에서 적당히 주입을 할 수도 있다. 지금은 크게 상관없을지 모른다. </p>
<p>하지만 프로젝트가 복잡해진다면? </p>
<p>의존성 주입 로직이 여러 곳에 흩뿌려진다. 이해하기 힘들다. 강하게 결합되는 부분도 앱의 여러 객체에 걸쳐 생긴다. </p>
<p>이걸 막기 위해서 우리는 깔끔하게, 앱 전체의 모-든 의존성 주입을 책임지는 별도 객체를 만든다. </p>
<p>이걸 Dependency Injection Container, <strong>DI Container</strong>라고 부른다. </p>
<p>DI Container는 특정 추상 타입을 필요로 하는 A 객체가 있을 때, 특정 추상 타입을 따르는 구체 타입 인스턴스를 생성해서 A 객체에 주입하는 역할을 담당한다.</p>
<p>다시 말해, 의존성을 해결해준다. 이것을 'resolve'한다고 표현한다. </p>
<p>하위 객체들은, 구체 객체에 대해서 전혀 몰라도 된다 내가 가진 의존성(추상 타입)의 정보만 넘긴다. DI Container에서 알아서 구체 객체를 넣어주게 된다.</p>
<p>아까 등장했던 이 코드를 다시보자.</p>
<pre><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">var</span> recommendationController <span class="token operator">=</span> <span class="token function">LocationSearchRecommendationController</span><span class="token punctuation">(</span>
	dependency<span class="token punctuation">:</span> <span class="token function">Recommendator</span><span class="token punctuation">(</span>
    	httpService<span class="token punctuation">:</span> <span class="token function">ResponseSuccessStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre>
<p>DI Container를 사용하면 이렇게 바뀐다.</p>
<pre><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">var</span> recommendationController<span class="token punctuation">:</span> <span class="token builtin">LocationSearchRecommendationController</span><span class="token operator">?</span>

<span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    recommendationController <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token builtin">LocationSearchRecommendationController</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>DI Container는 직접 만들 수도 있다. 하지만 대부분 서드 파티 라이브러리에서 잘 구현을 해놓았다. Swinject가 가장 인기있는 라이브러리 중 하나고, 그 외에도 많다. </p>
<p>DI Container의 원리나 사용법까지는 주제를 벗어나니까, 다음에 다시 다뤄보도록 하자!</p>
<h1 id="요약-정리">요약 정리</h1>
<ul>
<li>이번 프로젝트에서는 리팩토링을 의식적으로 연습했다.</li>
<li>리팩토링 대상은 위치를 선택해 숙박을 검색하는 기능이다.</li>
<li>첫번째, ViewController에서 <strong>데이터 소스와 데이터 로딩을 분리</strong>했다.</li>
<li>두번째, <code>UICollectionViewDelegate</code>를 분리했을 때 오히려 결합도가 높아져서, DataSource에 합쳤다.</li>
<li>세번쨰, <strong>객체 간 의존성을 추상화</strong>하고 DI Container로 주입했다.</li>
<li>결과적으로 ViewController는 가벼워졌고, 뚜렷한 책임을 가진 작은 객체로 나눌 수 있었으며, 런타임에 쉽게 의존성을 갈아끼울 수 있게 됐다.</li>
</ul>
</body>
</html>
